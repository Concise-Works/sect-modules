\vspace{-2em}
\section{Computers \& Number Base Systems}
 

\begin{Def}[Turing Machine]

    A \textbf{Turing Machine} is a theoretical computational model used to describe the capabilities of a general-purpose \textbf{computer}. It consists of an infinite tape (memory) and a read/write head processing symbols on the tape, one at a time, according to a set of predefined rules. The machine moves left or right, reading or writing symbols, and changing states based on what it reads. 
    
    The machine \textbf{halts} once it reaches a final state or continues indefinitely. Serving as a flexible, \textbf{higher-order function} (a function which receives functions).
\end{Def}

\begin{Def}[Von Neumann Architecture]

    Modern computers operate on a model known as the \textbf{Von Neumann architecture}, which consists of three primary components:
    \begin{enumerate}
        \item \textbf{Memory}: Stores data and instructions as sequences of bits.
        \item \textbf{Arithmetic and Logic Unit (ALU)}: Executes operations such as addition, subtraction, multiplication, and division on numbers stored in memory.
        \item \textbf{Control Unit}: Directs the execution of instructions and manages the flow of data between memory and the ALU.
    \end{enumerate}
    
    \noindent
    Where numbers are stored in memory cells, each cell holding an integer value represented in a fixed base, typically \(B = 2\), meaning \textbf{binary}. Where each digit is less than the base \(B\). We represent integers in memory as:
    
    \[
    a = \sum_{i=0}^{k-1} a_i B^i
    \]
    
    \noindent
    where \( a_i \) represents the individual digits, and \(B\) is the base. For large integers, computations may require manipulating several memory cells to store the full number.
\end{Def}

\noindent
\textbf{Example:} Consider the integer $a = 13$, and let us represent it in base $B = 2$ (binary). We can express this number as a sum of powers of $2$, corresponding to the binary representation of $13$:
    
\[
a = 1 \cdot 2^3 + 1 \cdot 2^2 + 0 \cdot 2^1 + 1 \cdot 2^0 = 8 + 4 + 0 + 1 = 13
\]

\noindent
In binary, this is represented as the sequence of digits: $a = (1101)_2$. Here, the coefficients $a_3 = 1$, $a_2 = 1$, $a_1 = 0$, and $a_0 = 1$ correspond to the binary digits of $13$.

\noindent
Similarly, if we want to represent $a = 45$ in base \textbf{$B = 10$ (decimal)}, we write:

\[
a = 4 \cdot 10^1 + 5 \cdot 10^0 = 40 + 5 = 45
\]

\noindent
In this case, the coefficients $a_1 = 4$ and $a_0 = 5$ correspond to the decimal digits of $45$.


\begin{Def}[Hexadecimal]
    
        \textbf{Hexadecimal} base $B=16$, using digits 0-9 and the letters A-F, where $A=10$, $B=11$, $C=12$, $D=13$, $E=14$, and $F=15$. Hexadecimal is commonly used in computing due to its compact representation of binary data. For example, a \textbf{byte} (8 bits) can be represented as two hexadecimal digits, simplifying the display of binary data.
\end{Def}


\begin{theo}[Base $2\leftrightarrow16$ Conversion]

    Let bases \( B:=2 \) (binary) and \( H:=16 \) (hexadecimal). At a high-level:

    \vspace{.5em}
    
    \noindent \textbf{Binary to Hexadecimal:}
    \begin{enumerate}
        \item Group $B$ digits in sets of 4, right to left. \textbf{Pad} leftmost group with 0's if necessary for a full group.
        \item Compute each group, replacing the result with their $H$ digit.
        \item Finally, combine each $H$ group.
    \end{enumerate}
    
    \noindent \textbf{Hexadecimal to Binary:}
    \begin{enumerate}
        \item Convert each $H$ digit into a 4 bit $B$ group.
        \item Finally, combine all $B$ groups.
    \end{enumerate}
    \noindent
    Additionally we may also trim any leading 0's.
\end{theo}

\noindent
\textbf{Example:}
    \begin{itemize}
        \item Binary to Hexadecimal:
        \[
        101101111010_2 \quad \Rightarrow \quad \text{Group as } ([1011] \ [0111] \ [1010]) \quad \Rightarrow \quad B7A_{16}
        \]
        \item Hexadecimal to Binary:
        \[
        3F5_{16} \quad \Rightarrow \quad [0011]\ [1111]\ [0101]_2 \Rightarrow \quad 1111110101_2
        \]
        \noindent
    \end{itemize}
    \noindent

\newpage 

\noindent
The following definition is for completeness: applications of such a base are currently uncommon.
\begin{Def}[Unary]
    
    \textbf{Unary}, base $B=1$. A system where each number is represented by a sequence of $B$ symbols. Where the number $n$ is represented by $n$ symbols. Often used in theoretical computer science to prove the existence of computable functions.
\end{Def}
\noindent
\textbf{Example:} The number $5$ in unary is represented by $5$ symbols: $5 = \texttt{IIIII}$ or $2= \texttt{II}$. There is no concept of 0, the absence of symbols represents 0.\\
\begin{Def}[Most \& Least Significant Bit]
    
    In a binary number, the \textbf{most significant bit (MSB)} is the leftmost bit. The \textbf{least significant bit (LSB)} is the rightmost bit.
\end{Def}
\textbf{Example:} Consider this byte (8 bits), $[1111 \ 1110]_2$, the MSB = 1 and the LSB = 0.  

\begin{theo}[Adding Binary]

    We may use the add and carry method alike decimal addition:
    \textbf{Binary Addition Rules:}
    \begin{itemize}
        \item $0 + 0 = 0$
        \item $0 + 1 = 1$
        \item $1 + 0 = 1$
        \item $1 + 1 = 0 \quad (\text{add 1 to the next digit (left)})$
    \end{itemize}
    \noindent
    We call the last step, \textbf{carry}, as we carry our overflow to the next digit.
\end{theo}

    \noindent
    \textbf{Example:} Adding $0010\ 0011\ 0100_2$ and $0100_2$:
    \begin{equation*}
        \begin{array}{B3}
             1       &                             1000 &  \carry 0\textcolor{red}{1}00 \\
              {} + 0 &                             0001 &  0\textcolor{red}{1}00 \\ \hline
                   1 &                             1001 &  1000 \\
        \end{array}
        \end{equation*}
\noindent
Where $[1\ 1000\ 0100]_2 + [0\ 0001\ 0100]_2 = [1\ 1001\ 1000]_2$.

\newpage

\begin{theo}[Signed Binary Numbers - Two's Complement]
    
    In a \textbf{two's complement system}, an $n$-bit signed (positive or negative) binary number can represent values in the range $[-2^{n-1}, 2^{n-1}-1]$. Then by most significant bit (MSB):
    \begin{itemize}
        \item If MSB is 0, the number is positive;
        \item If MSB is 1, the number is negative.
    \end{itemize}
    \noindent
    \textbf{Conversion to Two's Complement :}
    \begin{enumerate}
        \item Take an unsigned binary number and invert all bits, turning 0's to 1's and 1's to 0's.
        \item Finally add 1 to the least significant bit.
    \end{enumerate}
\end{theo}
\textbf{Example:} Converting $-5$ into a 4-bit two's complement:
    \begin{align*}
        5 \rightarrow 0101 \quad & \text{(binary for 5)} \\
         1010 \quad & \text{(inverted)} \\
         1011 \quad & \text{(add 1)}
    \end{align*}
    Thus, $-5$ is represented as $1011$ in 4-bits under two's complement.

    